package com.manu.mediasamples;

/**
 * @Desc: Test
 * @Author: jzman
 */
class Test {
//    private fun decode() {
//        val videoUrl = "http://vfx.mtime.cn/Video/2019/02/04/mp4/190204084208765161.mp4"
//        val mediaExtractor = MediaExtractor()
//        mediaExtractor.setDataSource(videoUrl)
//        val numTracks = mediaExtractor.trackCount
//        mediaExtractor.release()
//    }

    // 获取相机标识符
//    val array = mCameraManager.cameraIdList
//        Log.i(TAG, "openCamera > cameraIdList:${array.size}")
//            for (it in array) {
//        // 获取描述CameraDevice的属性
//        val cameraChar = mCameraManager.getCameraCharacteristics(it)
//        // 相机面对屏幕的方向，FRONT、BACK、EXTERNAL
//        val lensFacing = cameraChar.get(CameraCharacteristics.LENS_FACING)
//        Log.i(TAG, "openCamera > lensFacing:$lensFacing , $it")
//        // 屏幕顺时针旋转方向，有效值0、90、180、270
//        val sensorOrientation = cameraChar.get(CameraCharacteristics.SENSOR_ORIENTATION)
//        Log.i(TAG, "openCamera > sensorOrientation:$sensorOrientation")
//        // 获取该摄像头可用的流的配置，包括每种格式/尺寸组合的最小帧持续时间和停顿持续时间
//        val streamConfiguration =
//                cameraChar.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
//        Log.i(TAG, "openCamera > streamConfiguration:$streamConfiguration")
//
//        if (lensFacing != null && lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
//            mCameraId = it
//            break
//        }
//    }
}
